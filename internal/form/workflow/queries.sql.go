// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package workflow

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activate = `-- name: Activate :one
UPDATE workflow_versions AS wv
SET is_active = true
WHERE wv.form_id = $1
  AND wv.is_active = false
  AND wv.updated_at = (SELECT MAX(updated_at) FROM workflow_versions WHERE form_id = $1)
RETURNING id, form_id, last_editor, is_active, workflow, created_at, updated_at
`

func (q *Queries) Activate(ctx context.Context, formID uuid.UUID) (WorkflowVersion, error) {
	row := q.db.QueryRow(ctx, activate, formID)
	var i WorkflowVersion
	err := row.Scan(
		&i.ID,
		&i.FormID,
		&i.LastEditor,
		&i.IsActive,
		&i.Workflow,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNode = `-- name: CreateNode :one
WITH latest_workflow AS (
    SELECT wv.id, wv.is_active, wv.form_id, wv.workflow
    FROM workflow_versions AS wv
    WHERE wv.form_id = $1
    ORDER BY wv.updated_at DESC
    LIMIT 1
    FOR UPDATE
),
new_section AS (
    INSERT INTO sections (form_id, title, progress)
    SELECT lw.form_id, 'New Section', 'draft'
    FROM latest_workflow AS lw
    WHERE $3::node_type = 'section'
    RETURNING id
),
node_id AS (
    SELECT COALESCE((SELECT id FROM new_section), gen_random_uuid()) AS id
),
new_node AS (
    SELECT jsonb_build_object(
        'id', node_id.id,
        'label', 'New ' || initcap($3::text),
        'type', $3::node_type
    ) AS node
    FROM node_id
),
updated AS (
    UPDATE workflow_versions AS wv
    SET workflow = lw.workflow || jsonb_build_array(new_node.node),
        last_editor = $2,
        updated_at = now()
    FROM latest_workflow AS lw, new_node
    WHERE wv.id = lw.id 
      AND lw.is_active = false
    RETURNING wv.workflow, wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.created_at, wv.updated_at
),
created AS (
    INSERT INTO workflow_versions (form_id, last_editor, workflow)
    SELECT $1, $2, lw.workflow || jsonb_build_array(new_node.node)
    FROM latest_workflow AS lw, new_node
    WHERE lw.is_active = true
    RETURNING workflow, id, form_id, last_editor, is_active, created_at, updated_at
)
SELECT 
    (SELECT node->>'id' FROM new_node)::uuid AS id,
    (SELECT node->>'type' FROM new_node)::node_type AS type,
    (SELECT node->>'label' FROM new_node) AS label
FROM updated, new_node
UNION ALL
SELECT 
    (SELECT node->>'id' FROM new_node)::uuid AS id,
    (SELECT node->>'type' FROM new_node)::node_type AS type,
    (SELECT node->>'label' FROM new_node) AS label
FROM created, new_node
`

type CreateNodeParams struct {
	FormID     uuid.UUID
	LastEditor uuid.UUID
	Type       NodeType
}

type CreateNodeRow struct {
	ID    uuid.UUID
	Type  NodeType
	Label interface{}
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (CreateNodeRow, error) {
	row := q.db.QueryRow(ctx, createNode, arg.FormID, arg.LastEditor, arg.Type)
	var i CreateNodeRow
	err := row.Scan(&i.ID, &i.Type, &i.Label)
	return i, err
}

const get = `-- name: Get :one
SELECT workflow, id, form_id, last_editor, is_active, created_at, updated_at
FROM workflow_versions
WHERE form_id = $1
ORDER BY updated_at DESC
LIMIT 1
`

type GetRow struct {
	Workflow   []byte
	ID         uuid.UUID
	FormID     uuid.UUID
	LastEditor uuid.UUID
	IsActive   bool
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
}

func (q *Queries) Get(ctx context.Context, formID uuid.UUID) (GetRow, error) {
	row := q.db.QueryRow(ctx, get, formID)
	var i GetRow
	err := row.Scan(
		&i.Workflow,
		&i.ID,
		&i.FormID,
		&i.LastEditor,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const update = `-- name: Update :one
WITH latest AS (
    SELECT wv.id, wv.is_active, wv.form_id
    FROM workflow_versions AS wv
    WHERE wv.form_id = $1
    ORDER BY wv.updated_at DESC
    LIMIT 1
    FOR UPDATE
),
updated AS (
    UPDATE workflow_versions AS wv
    SET workflow = $3, last_editor = $2, updated_at = now()
    FROM latest
    WHERE wv.id = latest.id 
      AND latest.is_active = false
    RETURNING wv.workflow, wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.created_at, wv.updated_at
),
created AS (
    INSERT INTO workflow_versions (form_id, last_editor, workflow)
    SELECT $1, $2, $3
    FROM latest
    WHERE latest.is_active = true
    RETURNING workflow, id, form_id, last_editor, is_active, created_at, updated_at
)
SELECT workflow, id, form_id, last_editor, is_active, created_at, updated_at FROM updated
UNION ALL
SELECT workflow, id, form_id, last_editor, is_active, created_at, updated_at FROM created
`

type UpdateParams struct {
	FormID     uuid.UUID
	LastEditor uuid.UUID
	Workflow   []byte
}

type UpdateRow struct {
	Workflow   []byte
	ID         uuid.UUID
	FormID     uuid.UUID
	LastEditor uuid.UUID
	IsActive   bool
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (UpdateRow, error) {
	row := q.db.QueryRow(ctx, update, arg.FormID, arg.LastEditor, arg.Workflow)
	var i UpdateRow
	err := row.Scan(
		&i.Workflow,
		&i.ID,
		&i.FormID,
		&i.LastEditor,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
