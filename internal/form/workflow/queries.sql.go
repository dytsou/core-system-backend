// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package workflow

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activate = `-- name: Activate :one
WITH current_active AS (
    -- Get the currently active workflow version (if any) for comparison
    SELECT wv.id, wv.workflow
    FROM workflow_versions AS wv
    WHERE wv.form_id = $1
      AND wv.is_active = true
    ORDER BY wv.updated_at DESC
    LIMIT 1
),
latest AS (
    -- Get the latest workflow version (regardless of active status)
    SELECT wv.id, wv.is_active, wv.workflow
    FROM workflow_versions AS wv
    WHERE wv.form_id = $1
    ORDER BY wv.updated_at DESC
    LIMIT 1
),
request_workflow AS (
    -- Use the workflow from the request body
    SELECT $3::jsonb AS workflow
),
should_activate AS (
    /*
    Determine if activation should proceed and what action to take:
    
    Decision logic:
    1. If no workflow version exists -> create first version, then activate
    2. Else if request_workflow == current_active AND latest is active -> skip (unchanged)
    3. Else if latest is not active -> update latest with request_workflow, then activate
    4. Else (latest is active but request != current_active) -> create new version, then activate
    
    Fields:
    - latest_id: ID of the latest workflow version (by updated_at), NULL if none exists
    - latest_is_active: Whether the latest version is currently active
    - can_activate: Whether we should proceed with activation
    - should_update_latest: Whether to update the latest version (vs creating new one)
    */
    SELECT 
        l.id AS latest_id,
        l.is_active AS latest_is_active,
        CASE 
            -- No latest version exists - can activate (will create first version)
            WHEN l.id IS NULL THEN true
            -- Request matches current active AND latest is active - skip activation
            WHEN ca.id IS NOT NULL AND rw.workflow IS NOT DISTINCT FROM ca.workflow AND l.is_active = true THEN false
            -- Latest version is inactive - can activate (will update it first)
            WHEN l.is_active = false THEN true
            -- Latest is active but request differs from current active - can activate (will create new version)
            ELSE true
        END AS can_activate,
        CASE 
            -- Update latest version if it's inactive (before activating it)
            WHEN l.is_active = false THEN true
            -- Do not update if latest is active or doesn't exist (will create a new version)
            ELSE false
        END AS should_update_latest
    FROM request_workflow AS rw
    LEFT JOIN latest AS l ON true
    LEFT JOIN current_active AS ca ON true
),
updated_latest AS (
    -- Update the latest workflow version with request workflow if it's inactive
    UPDATE workflow_versions AS wv
    SET workflow = rw.workflow,
        last_editor = $2,
        updated_at = now()
    FROM should_activate AS sa, request_workflow AS rw
    WHERE wv.id = sa.latest_id
      AND wv.form_id = $1
      AND sa.should_update_latest = true
      AND sa.can_activate = true
    RETURNING wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.workflow, wv.created_at, wv.updated_at
),
created_version AS (
    -- Create a new workflow version if latest is active but request differs from current active,
    -- OR if no workflow version exists yet (first activation)
    INSERT INTO workflow_versions (form_id, last_editor, workflow)
    SELECT $1, $2, rw.workflow
    FROM request_workflow AS rw, should_activate AS sa
    WHERE sa.can_activate = true
      AND sa.should_update_latest = false
    RETURNING id, form_id, last_editor, is_active, workflow, created_at, updated_at
),
deactivated AS (
    -- Deactivate all currently active workflow versions (only if we're going to activate a new one)
    UPDATE workflow_versions AS wv
    SET is_active = false
    FROM should_activate AS sa
    WHERE wv.form_id = $1
      AND wv.is_active = true
      AND sa.can_activate = true
    RETURNING wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.workflow, wv.created_at, wv.updated_at
),
activated AS (
    -- Activate the updated latest version or the newly created version
    UPDATE workflow_versions AS wv
    SET is_active = true, 
        last_editor = $2
    WHERE wv.form_id = $1
      AND (
        wv.id IN (SELECT id FROM updated_latest)
        OR wv.id IN (SELECT id FROM created_version)
      )
      AND wv.is_active = false
    RETURNING wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.workflow, wv.created_at, wv.updated_at
),
reverted_update AS (
    -- Revert deactivation if activation failed (restore previous active state)
    UPDATE workflow_versions AS wv
    SET is_active = true
    FROM deactivated AS d
    WHERE wv.id = d.id
      AND NOT EXISTS (SELECT 1 FROM activated)
    RETURNING wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.workflow, wv.created_at, wv.updated_at
),
reverted AS (
    -- Select the most recently reverted workflow version
    SELECT id, form_id, last_editor, is_active, workflow, created_at, updated_at
    FROM reverted_update
    ORDER BY updated_at DESC
    LIMIT 1
),
unchanged AS (
    -- Return the current active workflow when activation is skipped
    -- (request_workflow == current_active AND latest is active)
    SELECT wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.workflow, wv.created_at, wv.updated_at
    FROM workflow_versions AS wv
    WHERE wv.id IN (SELECT id FROM current_active)
      AND EXISTS (
        SELECT 1 FROM should_activate AS sa 
        WHERE sa.can_activate = false
      )
)
SELECT id, form_id, last_editor, is_active, workflow, created_at, updated_at FROM activated
UNION ALL
SELECT id, form_id, last_editor, is_active, workflow, created_at, updated_at FROM reverted
UNION ALL
SELECT id, form_id, last_editor, is_active, workflow, created_at, updated_at FROM unchanged
`

type ActivateParams struct {
	FormID     uuid.UUID
	LastEditor uuid.UUID
	Workflow   []byte
}

type ActivateRow struct {
	ID         uuid.UUID
	FormID     uuid.UUID
	LastEditor uuid.UUID
	IsActive   bool
	Workflow   []byte
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
}

// Return the activated version, reverted version (if activation failed), or unchanged version (if skipped)
func (q *Queries) Activate(ctx context.Context, arg ActivateParams) (ActivateRow, error) {
	row := q.db.QueryRow(ctx, activate, arg.FormID, arg.LastEditor, arg.Workflow)
	var i ActivateRow
	err := row.Scan(
		&i.ID,
		&i.FormID,
		&i.LastEditor,
		&i.IsActive,
		&i.Workflow,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNode = `-- name: CreateNode :one
WITH latest_workflow AS (
    SELECT wv.id, wv.is_active, wv.form_id, wv.workflow
    FROM workflow_versions AS wv
    WHERE wv.form_id = $1
    ORDER BY wv.updated_at DESC
    LIMIT 1
    FOR UPDATE
),
new_section AS (
    INSERT INTO sections (form_id, title, progress)
    SELECT lw.form_id, 'New Section', 'draft'
    FROM latest_workflow AS lw
    WHERE $3::node_type = 'section'
    RETURNING id
),
node_id AS (
    SELECT COALESCE((SELECT id FROM new_section), gen_random_uuid()) AS id
),
new_node AS (
    SELECT jsonb_build_object(
        'id', node_id.id,
        'label', 'New ' || initcap($3::text),
        'type', $3::node_type
    ) AS node
    FROM node_id
),
updated AS (
    UPDATE workflow_versions AS wv
    SET workflow = lw.workflow || jsonb_build_array(new_node.node),
        last_editor = $2,
        updated_at = now()
    FROM latest_workflow AS lw, new_node
    WHERE wv.id = lw.id 
      AND lw.is_active = false
    RETURNING wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.workflow, wv.created_at, wv.updated_at
),
created AS (
    INSERT INTO workflow_versions (form_id, last_editor, workflow)
    SELECT $1, $2, lw.workflow || jsonb_build_array(new_node.node)
    FROM latest_workflow AS lw, new_node
    WHERE lw.is_active = true
    RETURNING id, form_id, last_editor, is_active, workflow, created_at, updated_at
)
SELECT 
    (SELECT node->>'id' FROM new_node)::uuid AS node_id,
    (SELECT node->>'type' FROM new_node)::node_type AS node_type,
    (SELECT node->>'label' FROM new_node) AS node_label,
    u.workflow AS workflow
FROM updated AS u, new_node
UNION ALL
SELECT 
    (SELECT node->>'id' FROM new_node)::uuid AS node_id,
    (SELECT node->>'type' FROM new_node)::node_type AS node_type,
    (SELECT node->>'label' FROM new_node) AS node_label,
    c.workflow AS workflow
FROM created AS c, new_node
`

type CreateNodeParams struct {
	FormID     uuid.UUID
	LastEditor uuid.UUID
	Type       NodeType
}

type CreateNodeRow struct {
	NodeID    uuid.UUID
	NodeType  NodeType
	NodeLabel interface{}
	Workflow  []byte
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (CreateNodeRow, error) {
	row := q.db.QueryRow(ctx, createNode, arg.FormID, arg.LastEditor, arg.Type)
	var i CreateNodeRow
	err := row.Scan(
		&i.NodeID,
		&i.NodeType,
		&i.NodeLabel,
		&i.Workflow,
	)
	return i, err
}

const deleteNode = `-- name: DeleteNode :one
WITH latest_workflow AS (
    SELECT wv.id, wv.is_active, wv.form_id, wv.workflow
    FROM workflow_versions AS wv
    WHERE wv.form_id = $1
    ORDER BY wv.updated_at DESC
    LIMIT 1
    FOR UPDATE
),
deleted_node_id AS (
    SELECT $3::text AS deleted_id
),
node_to_delete AS (
    SELECT 
        node->>'id' AS node_id,
        node->>'type' AS node_type
    FROM latest_workflow AS lw,
    LATERAL jsonb_array_elements(COALESCE(lw.workflow, '[]'::jsonb)) AS node
    WHERE node->>'id' = (SELECT deleted_id FROM deleted_node_id)
    LIMIT 1
),
deleted_section AS (
    DELETE FROM sections
    WHERE id = (SELECT node_id::uuid FROM node_to_delete)
      AND EXISTS (SELECT 1 FROM node_to_delete WHERE node_type = 'section')
    RETURNING id
),
remaining_nodes AS (
    SELECT node
    FROM latest_workflow AS lw,
    LATERAL jsonb_array_elements(COALESCE(lw.workflow, '[]'::jsonb)) AS node
    WHERE node->>'id' != (SELECT deleted_id FROM deleted_node_id)
),
/* 
Example of node_fields_expanded: 
node_id   | field_key  | cleaned_value
"node-a"  | "id"       | "node-a"
"node-a"  | "type"     | "start"
"node-a"  | "label"    | "Start"
"node-a"  | "next"     | null  ← NULLIFIED!
"node-c"  | "id"       | "node-c"
"node-c"  | "type"     | "condition"
"node-c"  | "label"    | "Check"
"node-c"  | "nextTrue" | null  ← NULLIFIED!
"node-c"  | "nextFalse"| "node-d"
"node-d"  | "id"       | "node-d"
"node-d"  | "type"     | "end"
"node-d"  | "label"    | "End"
*/
node_fields_expanded AS (
    SELECT 
        node->>'id' AS node_id,
        field_key,
        field_value
    FROM remaining_nodes,
    LATERAL jsonb_each(COALESCE(node, '{}'::jsonb)) AS node_fields(field_key, field_value)
),
cleaned_node_fields AS (
    SELECT 
        node_id,
        field_key,
        CASE 
            -- Nullify reference fields that point to the deleted node
            WHEN field_key IN ('next', 'nextTrue', 'nextFalse') 
             AND field_value::text = (SELECT deleted_id FROM deleted_node_id)
            THEN 'null'::jsonb
            ELSE field_value
        END AS cleaned_value
    FROM node_fields_expanded
),
cleaned_nodes AS (
    SELECT 
        jsonb_object_agg(field_key, cleaned_value ORDER BY field_key) AS cleaned_node
    FROM cleaned_node_fields
    GROUP BY node_id
),
cleaned_workflow AS (
    SELECT COALESCE(jsonb_agg(cleaned_node), '[]'::jsonb) AS workflow
    FROM cleaned_nodes
),
updated AS (
    UPDATE workflow_versions AS wv
    SET 
        workflow = COALESCE(cw.workflow, '[]'::jsonb),
        last_editor = $2,
        updated_at = now()
    FROM latest_workflow AS lw, cleaned_workflow AS cw
    WHERE wv.id = lw.id 
      AND lw.is_active = false
    RETURNING wv.workflow
),
created AS (
    INSERT INTO workflow_versions (form_id, last_editor, workflow)
    SELECT $1, $2, COALESCE(cw.workflow, '[]'::jsonb)
    FROM latest_workflow AS lw, cleaned_workflow AS cw
    WHERE lw.is_active = true
    RETURNING workflow
)
SELECT workflow FROM updated
UNION ALL
SELECT workflow FROM created
`

type DeleteNodeParams struct {
	FormID     uuid.UUID
	LastEditor uuid.UUID
	NodeID     string
}

// Deletes a node from the workflow and nullifies all references to it in other nodes
// Convert deleted node ID to text format for JSONB comparison
// Extract information about the node to be deleted
// Delete associated section if the node is a section type
// Get all nodes except the one being deleted
// Expand each node into individual key-value pairs
// --------|------------|------------
// Clean each field: nullify reference fields that point to the deleted node
// Rebuild nodes from cleaned fields
// Rebuild the workflow array from cleaned nodes
// Update draft workflow version in place
// Create new draft version if current version is active
// Return workflow as JSONB
func (q *Queries) DeleteNode(ctx context.Context, arg DeleteNodeParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, deleteNode, arg.FormID, arg.LastEditor, arg.NodeID)
	var workflow []byte
	err := row.Scan(&workflow)
	return workflow, err
}

const get = `-- name: Get :one
SELECT workflow, id, form_id, last_editor, is_active, created_at, updated_at
FROM workflow_versions
WHERE form_id = $1
ORDER BY updated_at DESC
LIMIT 1
`

type GetRow struct {
	Workflow   []byte
	ID         uuid.UUID
	FormID     uuid.UUID
	LastEditor uuid.UUID
	IsActive   bool
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
}

func (q *Queries) Get(ctx context.Context, formID uuid.UUID) (GetRow, error) {
	row := q.db.QueryRow(ctx, get, formID)
	var i GetRow
	err := row.Scan(
		&i.Workflow,
		&i.ID,
		&i.FormID,
		&i.LastEditor,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const update = `-- name: Update :one
WITH latest_workflow AS (
    SELECT wv.id, wv.is_active, wv.form_id
    FROM workflow_versions AS wv
    WHERE wv.form_id = $1
    ORDER BY wv.updated_at DESC
    LIMIT 1
    FOR UPDATE
),
updated AS (
    UPDATE workflow_versions AS wv
    SET workflow = $3, last_editor = $2, updated_at = now()
    FROM latest_workflow AS lw
    WHERE wv.id = lw.id 
      AND lw.is_active = false
    RETURNING wv.workflow, wv.id, wv.form_id, wv.last_editor, wv.is_active, wv.created_at, wv.updated_at
),
created AS (
    INSERT INTO workflow_versions (form_id, last_editor, workflow)
    SELECT $1, $2, $3
    FROM latest_workflow AS lw
    WHERE lw.is_active = true
    RETURNING workflow, id, form_id, last_editor, is_active, created_at, updated_at
)
SELECT workflow, id, form_id, last_editor, is_active, created_at, updated_at FROM updated
UNION ALL
SELECT workflow, id, form_id, last_editor, is_active, created_at, updated_at FROM created
`

type UpdateParams struct {
	FormID     uuid.UUID
	LastEditor uuid.UUID
	Workflow   []byte
}

type UpdateRow struct {
	Workflow   []byte
	ID         uuid.UUID
	FormID     uuid.UUID
	LastEditor uuid.UUID
	IsActive   bool
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (UpdateRow, error) {
	row := q.db.QueryRow(ctx, update, arg.FormID, arg.LastEditor, arg.Workflow)
	var i UpdateRow
	err := row.Scan(
		&i.Workflow,
		&i.ID,
		&i.FormID,
		&i.LastEditor,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
