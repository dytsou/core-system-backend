// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package form

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const create = `-- name: Create :one
WITH created AS (
    INSERT INTO forms (title, description, preview_message, unit_id, last_editor, deadline)
    VALUES ($1, $2, $3, $4, $5, $6)
    RETURNING id, title, description, preview_message, status, unit_id, last_editor, deadline, created_at, updated_at
),
workflow_created AS (
    INSERT INTO workflow_versions (form_id, last_editor, workflow)
    SELECT 
        id, 
        last_editor,
        jsonb_build_array(
            jsonb_build_object(
                'id', start_node_id,
                'label', '開始表單',
                'type', 'start',
                'next', end_node_id
            ),
            jsonb_build_object(
                'id', end_node_id,
                'label', '確認/送出',
                'type', 'end'
            )
        )
    FROM created, LATERAL (
        SELECT gen_random_uuid() AS start_node_id, gen_random_uuid() AS end_node_id
    ) AS node_ids
)
SELECT 
    f.id, f.title, f.description, f.preview_message, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM created f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
`

type CreateParams struct {
	Title          string
	Description    pgtype.Text
	PreviewMessage pgtype.Text
	UnitID         pgtype.UUID
	LastEditor     uuid.UUID
	Deadline       pgtype.Timestamptz
}

type CreateRow struct {
	ID                  uuid.UUID
	Title               string
	Description         pgtype.Text
	PreviewMessage      pgtype.Text
	Status              Status
	UnitID              pgtype.UUID
	LastEditor          uuid.UUID
	Deadline            pgtype.Timestamptz
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	UnitName            pgtype.Text
	OrgName             pgtype.Text
	LastEditorName      pgtype.Text
	LastEditorUsername  pgtype.Text
	LastEditorAvatarUrl pgtype.Text
	LastEditorEmail     interface{}
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (CreateRow, error) {
	row := q.db.QueryRow(ctx, create,
		arg.Title,
		arg.Description,
		arg.PreviewMessage,
		arg.UnitID,
		arg.LastEditor,
		arg.Deadline,
	)
	var i CreateRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.PreviewMessage,
		&i.Status,
		&i.UnitID,
		&i.LastEditor,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnitName,
		&i.OrgName,
		&i.LastEditorName,
		&i.LastEditorUsername,
		&i.LastEditorAvatarUrl,
		&i.LastEditorEmail,
	)
	return i, err
}

const delete = `-- name: Delete :exec
DELETE FROM forms WHERE id = $1
`

func (q *Queries) Delete(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, delete, id)
	return err
}

const getByID = `-- name: GetByID :one
SELECT 
    f.id, f.title, f.description, f.preview_message, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM forms f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
WHERE f.id = $1
`

type GetByIDRow struct {
	ID                  uuid.UUID
	Title               string
	Description         pgtype.Text
	PreviewMessage      pgtype.Text
	Status              Status
	UnitID              pgtype.UUID
	LastEditor          uuid.UUID
	Deadline            pgtype.Timestamptz
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	UnitName            pgtype.Text
	OrgName             pgtype.Text
	LastEditorName      pgtype.Text
	LastEditorUsername  pgtype.Text
	LastEditorAvatarUrl pgtype.Text
	LastEditorEmail     interface{}
}

func (q *Queries) GetByID(ctx context.Context, id uuid.UUID) (GetByIDRow, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i GetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.PreviewMessage,
		&i.Status,
		&i.UnitID,
		&i.LastEditor,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnitName,
		&i.OrgName,
		&i.LastEditorName,
		&i.LastEditorUsername,
		&i.LastEditorAvatarUrl,
		&i.LastEditorEmail,
	)
	return i, err
}

const list = `-- name: List :many
SELECT 
    f.id, f.title, f.description, f.preview_message, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM forms f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
ORDER BY f.updated_at DESC
`

type ListRow struct {
	ID                  uuid.UUID
	Title               string
	Description         pgtype.Text
	PreviewMessage      pgtype.Text
	Status              Status
	UnitID              pgtype.UUID
	LastEditor          uuid.UUID
	Deadline            pgtype.Timestamptz
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	UnitName            pgtype.Text
	OrgName             pgtype.Text
	LastEditorName      pgtype.Text
	LastEditorUsername  pgtype.Text
	LastEditorAvatarUrl pgtype.Text
	LastEditorEmail     interface{}
}

func (q *Queries) List(ctx context.Context) ([]ListRow, error) {
	rows, err := q.db.Query(ctx, list)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRow
	for rows.Next() {
		var i ListRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.PreviewMessage,
			&i.Status,
			&i.UnitID,
			&i.LastEditor,
			&i.Deadline,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnitName,
			&i.OrgName,
			&i.LastEditorName,
			&i.LastEditorUsername,
			&i.LastEditorAvatarUrl,
			&i.LastEditorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listByUnit = `-- name: ListByUnit :many
SELECT 
    f.id, f.title, f.description, f.preview_message, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM forms f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
WHERE f.unit_id = $1
ORDER BY f.updated_at DESC
`

type ListByUnitRow struct {
	ID                  uuid.UUID
	Title               string
	Description         pgtype.Text
	PreviewMessage      pgtype.Text
	Status              Status
	UnitID              pgtype.UUID
	LastEditor          uuid.UUID
	Deadline            pgtype.Timestamptz
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	UnitName            pgtype.Text
	OrgName             pgtype.Text
	LastEditorName      pgtype.Text
	LastEditorUsername  pgtype.Text
	LastEditorAvatarUrl pgtype.Text
	LastEditorEmail     interface{}
}

func (q *Queries) ListByUnit(ctx context.Context, unitID pgtype.UUID) ([]ListByUnitRow, error) {
	rows, err := q.db.Query(ctx, listByUnit, unitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListByUnitRow
	for rows.Next() {
		var i ListByUnitRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.PreviewMessage,
			&i.Status,
			&i.UnitID,
			&i.LastEditor,
			&i.Deadline,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnitName,
			&i.OrgName,
			&i.LastEditorName,
			&i.LastEditorUsername,
			&i.LastEditorAvatarUrl,
			&i.LastEditorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setStatus = `-- name: SetStatus :one
UPDATE forms
SET status = $2, last_editor = $3, updated_at = now()
WHERE id = $1
RETURNING id, title, description, preview_message, status, unit_id, last_editor, deadline, created_at, updated_at
`

type SetStatusParams struct {
	ID         uuid.UUID
	Status     Status
	LastEditor uuid.UUID
}

func (q *Queries) SetStatus(ctx context.Context, arg SetStatusParams) (Form, error) {
	row := q.db.QueryRow(ctx, setStatus, arg.ID, arg.Status, arg.LastEditor)
	var i Form
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.PreviewMessage,
		&i.Status,
		&i.UnitID,
		&i.LastEditor,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const update = `-- name: Update :one
WITH updated AS (
    UPDATE forms
    SET title = $2, description = $3, preview_message = $4, last_editor = $5, deadline = $6, updated_at = now()
    WHERE forms.id = $1
    RETURNING id, title, description, preview_message, status, unit_id, last_editor, deadline, created_at, updated_at
)
SELECT 
    f.id, f.title, f.description, f.preview_message, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM updated f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
`

type UpdateParams struct {
	ID             uuid.UUID
	Title          string
	Description    pgtype.Text
	PreviewMessage pgtype.Text
	LastEditor     uuid.UUID
	Deadline       pgtype.Timestamptz
}

type UpdateRow struct {
	ID                  uuid.UUID
	Title               string
	Description         pgtype.Text
	PreviewMessage      pgtype.Text
	Status              Status
	UnitID              pgtype.UUID
	LastEditor          uuid.UUID
	Deadline            pgtype.Timestamptz
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	UnitName            pgtype.Text
	OrgName             pgtype.Text
	LastEditorName      pgtype.Text
	LastEditorUsername  pgtype.Text
	LastEditorAvatarUrl pgtype.Text
	LastEditorEmail     interface{}
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (UpdateRow, error) {
	row := q.db.QueryRow(ctx, update,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.PreviewMessage,
		arg.LastEditor,
		arg.Deadline,
	)
	var i UpdateRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.PreviewMessage,
		&i.Status,
		&i.UnitID,
		&i.LastEditor,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnitName,
		&i.OrgName,
		&i.LastEditorName,
		&i.LastEditorUsername,
		&i.LastEditorAvatarUrl,
		&i.LastEditorEmail,
	)
	return i, err
}
